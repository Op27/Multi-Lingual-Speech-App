/start
- We are developing an application with AI support.
- Let's resume work on our multilingual speech application. We're currently addressing a 400 Bad Request error when posting to the /process_audio endpoint. Our goal is to ensure seamless communication between the frontend and the Flask backend, particularly for audio processing and language translation functionalities. Can we start by examining the Flask backend for any issues in handling the FormData from the frontend? Additionally, let's review the frontend code to ensure it's correctly sending the audio and language data.
- In your response, please use "we" as this is a collaborative work. 
- To avoid mistakes, please suggest one changes/addition at each time so that I can test the changes. 
- Provide a full code of a particular section that needs to be updated/revised for app.py file to avoid mistakes in reflecting the updated changes.
- UI should include following elements:
a. A start recording button 
b. a box transcribed texts are displayed 
c. a box translated texts are displayed
d. a Drop down where users can select languages
e. a visual that correspond with recorded voice and output voice (optional) 

Current Status:
Project: Developing a multilingual speech application with a Flask backend.

Issue: Encountering a 400 Bad Request error when trying to post data to the /process_audio endpoint.

Completed:
Basic UI setup with recording functionality and language selection.
Flask backend with endpoints for processing audio, translating text, and synthesizing speech.

Recent Changes:
Updated sendAudioToServer function in script.js to send audio and language data to Flask backend.
Verified file locations and references for static files in Flask.


Next Steps:
Debug Flask Backend:

Check the /process_audio endpoint in app.py for handling FormData.
Add logging in Flask to print the received data for diagnosing the 400 error.
Verify FormData Handling:

Ensure the frontend is correctly appending both audio data and language to FormData.
Confirm the backend correctly extracts and processes this data.
Test in Isolation:

Consider testing the backend independently with a tool like Postman to isolate the issue.
Review Error Messages:

Pay close attention to any new error messages or logs for clues.


###index.html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Multilingual Speech App</title>
    <link rel="stylesheet" href="/static/style.css">
    <script src="/static/script.js"></script>

</head>
<body>
    <select id="language-dropdown" onchange="handleLanguageChange()">
        <option value="Spanish">Spanish</option>
        <option value="French">French</option>
    </select>

    <button id="start-record-btn">Start Recording</button>

    <div>
        <h2>Transcribed Text:</h2>
        <div id="transcribed-text-box"></div>
    </div>

    <div>
        <h2>Translated Text:</h2>
        <div id="translated-text-box"></div>
    </div>
</body>
</html>




###app.py code
from flask import Flask, request, jsonify, Response
import requests
from google.cloud import speech, texttospeech
from pydub import AudioSegment
import io
import logging

logging.basicConfig(level=logging.DEBUG)

app = Flask(__name__)

# Initialize Google Cloud Speech and Text-to-Speech clients
speech_client = speech.SpeechClient()
tts_client = texttospeech.TextToSpeechClient()

@app.route('/upload_audio', methods=['POST'])
def upload_audio(audio_file=None):
    if not audio_file:
        if 'audio' not in request.files:
            return jsonify({"message": "No audio file in request"}), 400
        audio_file = request.files['audio']

    audio_data = audio_file.read()
    audio_segment = AudioSegment.from_file(io.BytesIO(audio_data)).set_channels(1)

    if audio_segment.sample_width != 2:
        audio_segment = audio_segment.set_sample_width(2)
    if audio_segment.frame_rate != 16000:
        audio_segment = audio_segment.set_frame_rate(16000)

    audio_bytes = audio_segment.raw_data

    audio = speech.RecognitionAudio(content=audio_bytes)
    config = speech.RecognitionConfig(
        encoding=speech.RecognitionConfig.AudioEncoding.LINEAR16,
        sample_rate_hertz=16000,
        language_code="en-US",
        audio_channel_count=1
    )

    try:
        response = speech_client.recognize(config=config, audio=audio)
        transcript = response.results[0].alternatives[0].transcript
        return jsonify({"transcript": transcript})
    except Exception as e:
        return jsonify({"message": "Error processing audio", "error": str(e)}), 500

language_code_map = {
    'Spanish': 'es',  # Spanish language code
    'French': 'fr',   # Corrected French language code
    # Add other languages and their codes as needed
}


@app.route('/translate_text', methods=['POST'])
def translate_text():
    data = request.get_json(force=True)
    text_to_translate = data['text']
    target_language = data['language'].lower()

    # Hardcoding the target language code for 'fr'
    if target_language == 'fr':
        target_language_code = 'FR'
    else:
        return jsonify({"message": f"Unsupported target language: {target_language}"}), 400

    logging.debug(f"Target language code for 'fr': {target_language_code}")

    deepL_api_key = ''  
    url = "https://api-free.deepl.com/v2/translate"

    params = {
        'auth_key': deepL_api_key,
        'text': text_to_translate,
        'target_lang': target_language_code
    }

    response = requests.post(url, data=params)

    if response.status_code == 200:
        translated_text = response.json()['translations'][0]['text']
        return jsonify({"translated_text": translated_text})
    else:
        error_msg = f"DeepL API error: {response.status_code} - {response.text}"
        logging.error(error_msg)
        return jsonify({"message": "Translation failed", "error": error_msg}), response.status_code



@app.route('/synthesize_speech', methods=['POST'])
def synthesize_speech():
    data = request.get_json()
    text = data.get('text')
    language_code = data.get('language', 'en-US')  # Default to US English if not provided

    # Mapping for language codes to Text-to-Speech API format
    tts_language_code_map = {
        'es': 'es-ES',  # Spanish
        'fr': 'fr-FR',  # French
        # Add other mappings as needed
    }

    # Convert the two-letter code to the format expected by the Text-to-Speech API
    tts_language_code = tts_language_code_map.get(language_code, language_code)

    logging.debug(f"Synthesizing speech for: {text} in language: {tts_language_code}")

    synthesis_input = texttospeech.SynthesisInput(text=text)
    voice = texttospeech.VoiceSelectionParams(
        language_code=tts_language_code,
        ssml_gender=texttospeech.SsmlVoiceGender.FEMALE
    )
    audio_config = texttospeech.AudioConfig(audio_encoding=texttospeech.AudioEncoding.MP3)

    try:
        response = tts_client.synthesize_speech(input=synthesis_input, voice=voice, audio_config=audio_config)
        if len(response.audio_content) == 0:
            logging.error("No audio content generated by the Text-to-Speech API.")
            return jsonify({"message": "Error synthesizing speech: No audio content"}), 500
        return Response(response.audio_content, mimetype='audio/mp3')
    except Exception as e:
        logging.error(f"Error in text-to-speech synthesis: {e}")
        return jsonify({"message": "Error in text-to-speech synthesis", "error": str(e)}), 500


@app.route('/process_audio', methods=['POST'])
def process_audio():
    if 'audio' not in request.files or 'language' not in request.form:
        return jsonify({"message": "Audio file or language not provided"}), 400

    audio_file = request.files['audio']
    selected_language = request.form['language']

    # Debug log for selected language
    logging.debug(f"Selected language: {selected_language}")

    try:
        # Transcribe the audio file
        audio_file.seek(0)  # Reset file read pointer
        audio_data = audio_file.read()
        audio_segment = AudioSegment.from_file(io.BytesIO(audio_data)).set_channels(1)

        if audio_segment.sample_width != 2:
            audio_segment = audio_segment.set_sample_width(2)
        if audio_segment.frame_rate != 16000:
            audio_segment = audio_segment.set_frame_rate(16000)

        audio_bytes = audio_segment.raw_data
        audio = speech.RecognitionAudio(content=audio_bytes)
        config = speech.RecognitionConfig(
            encoding=speech.RecognitionConfig.AudioEncoding.LINEAR16,
            sample_rate_hertz=16000,
            language_code="en-US",
            audio_channel_count=1
        )

        response = speech_client.recognize(config=config, audio=audio)
        transcript = response.results[0].alternatives[0].transcript

        logging.debug(f"Transcript (English): {transcript}")

        # Translate the transcript
        translation_response = requests.post('http://localhost:5000/translate_text', json={'text': transcript, 'language': selected_language})
        if translation_response.status_code != 200:
            return jsonify({"message": "Error translating text"}), translation_response.status_code
        translated_text = translation_response.json()['translated_text']

        logging.debug(f"Translated text (Target Language - {selected_language}): {translated_text}")

        # Synthesize speech from the translated text
        speech_response = requests.post('http://localhost:5000/synthesize_speech', json={'text': translated_text, 'language': selected_language})
        if speech_response.status_code != 200:
            return jsonify({"message": "Error synthesizing speech"}), speech_response.status_code
        audio_content = speech_response.content

        logging.debug(f"Type of audio content: {type(audio_content)}")
        logging.debug(f"Length of audio content: {len(audio_content)}")

        return Response(audio_content, mimetype='audio/mp3')

    except Exception as e:
        logging.error(f"Error in audio processing: {e}")
        return jsonify({"message": "Error in audio processing", "error": str(e)}), 500

@app.route('/')
def index():
    return app.send_static_file('index.html')


if __name__ == '__main__':
    app.run(debug=True)


###style.css
body {
  background-color: black;
  color: white;
  font-family: Arial, sans-serif;
}

select, button {
  background-color: #333;
  color: white;
  border: 1px solid gray;
  padding: 5px 10px;
  margin: 5px;
  border-radius: 5px;
}

div {
  margin: 10px 0;
}

#transcribed-text-box, #translated-text-box {
  background-color: #222;
  border: 1px solid gray;
  padding: 10px;
  min-height: 100px;
  overflow-y: auto;
}

h2 {
  color: #4CAF50;
}


###script.js
document.addEventListener('DOMContentLoaded', function() {
  const startRecordBtn = document.getElementById('start-record-btn');
  const transcribedTextBox = document.getElementById('transcribed-text-box');
  const translatedTextBox = document.getElementById('translated-text-box');

  let isRecording = false;
  let mediaRecorder;
  let audioChunks = [];

  startRecordBtn.addEventListener('click', function() {
      if (!isRecording) {
          startRecording();
      } else {
          stopRecording();
      }
      isRecording = !isRecording;
  });

  function startRecording() {
      navigator.mediaDevices.getUserMedia({ audio: true })
          .then(stream => {
              mediaRecorder = new MediaRecorder(stream);
              mediaRecorder.start();

              mediaRecorder.ondataavailable = function(e) {
                  audioChunks.push(e.data);
              };

              mediaRecorder.onstop = sendAudioToServer;
          });
      startRecordBtn.textContent = 'Stop Recording';
  }

  function stopRecording() {
      mediaRecorder.stop();
      startRecordBtn.textContent = 'Start Recording';
  }

  function sendAudioToServer() {
    const audioBlob = new Blob(audioChunks, { type: 'audio/wav' });
    const formData = new FormData();
    
    formData.append('audio', audioBlob);

    const selectedLanguage = document.getElementById('language-dropdown').value;
    
    formData.append('language', selectedLanguage);

    fetch('http://127.0.0.1:5000/process_audio', {
        method: 'POST',
        body: formData
    }).then(response => {
        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }
        return response.json();
    }).then(data => {
        transcribedTextBox.textContent = data.transcript;
        translatedTextBox.textContent = data.translated_text;
    }).catch(error => {
        console.error('Error:', error);
    });
}


});

